{
  "version": 3,
  "file": "main.css",
  "sources": [
    "..\\src\\HSlider.html",
    "..\\src\\VSlider.html"
  ],
  "sourcesContent": [
    "<svelte:window on:mouseup=\"stop(event)\" on:mousemove=\"move(event)\"/>\r\n<div class:hslider=\"true\">\r\n    <div class=\"bar\" ref:bar>\r\n        <div class=\"range\" ref:range>\r\n            {#if isRange}\r\n            <div class=\"left\" ref:left on:mousedown=\"start(event, 'left')\">\r\n                {#if hasTooltip}\r\n                    <div class=\"left-tick\" ref:leftTick>{parseFloat(low).toFixed()}</div>\r\n                {/if}\r\n            </div>\r\n            {/if}\r\n            <div class=\"right\" ref:right on:mousedown=\"start(event, 'right')\">\r\n                {#if hasTooltip}\r\n                    <div class=\"right-tick\" ref:rightTick>{parseFloat(high).toFixed()}</div>\r\n                {/if}\r\n            </div>\r\n        </div>\r\n    </div>\r\n    <slot></slot>\r\n</div>\r\n\r\n<style>    \r\n    .hslider {  \r\n        -webkit-touch-callout: none;\r\n        -webkit-user-select: none;\r\n        -khtml-user-select: none;\r\n        -moz-user-select: none;\r\n        -ms-user-select: none;\r\n        user-select: none;\r\n    }\r\n    .hslider .bar,\r\n    .hslider .bar .range,\r\n    .hslider .bar .range .left,\r\n    .hslider .bar .range .right {\r\n        position: relative;\r\n    }\r\n    .hslider .bar .range .left,\r\n    .hslider .bar .range .right {\r\n        width: 12px;\r\n        height: 12px;\r\n        cursor: pointer;\r\n    }    \r\n    .hslider .bar .range .left {\r\n        float: left;   \r\n    }\r\n    .hslider .bar .range .right {\r\n        float: right;    \r\n    }\r\n    .hslider .bar .range .left .left-tick,\r\n    .hslider .bar .range .right .right-tick {\r\n        position: relative;\r\n        left: -2px;\r\n        top: -18px;\r\n        display: none;\r\n    }\r\n</style>\r\n\r\n<script>\r\n    const TIMEOUT =  70;\r\n    export default {\r\n        data () {\r\n            return {\r\n                min: 0,\r\n                max: 0,\r\n                low: NaN,\r\n                high: 0,\r\n                step: 0,\r\n                tooltip: false,\r\n            };\r\n        },  \r\n        computed: {\r\n            isRange: ({low}) => !isNaN(parseFloat(low)),            \r\n            hasTooltip: ({tooltip}) => {\r\n                switch (typeof tooltip) {\r\n                    case 'boolean':\r\n                        return tooltip;\r\n                    case 'string':\r\n                        return tooltip.toLowerCase() === 'true';\r\n                    default:\r\n                        return false;\r\n                }                \r\n            }\r\n        },      \r\n        oncreate() {            \r\n            const {min, max, low, high, orientation, isRange} = this.get();\r\n            const {width, height} = this.refs.right.getBoundingClientRect();            \r\n            this._size = isRange ? 2 * width : width;\r\n            this._ratio = this._getRatio(min, max, this._size);\r\n            this._updateDom(min, max, low, high, this._size, this._ratio);\r\n        },\r\n        onupdate({changed, current, previous}) {            \r\n            if (changed.low) {\r\n                const lo = parseFloat(current.low);\r\n                if (!isNaN(lo)) {\r\n                    const {min, max, high} = this.get();\r\n                    this._updateDom (min, max, lo, high, this._size, this._ratio);\r\n                }\r\n            }\r\n            if (changed.high) {\r\n                const hi = parseFloat(current.high);\r\n                if (!isNaN(hi)) {\r\n                    const {min, max, low} = this.get();\r\n                    this._updateDom (min, max, low, hi, this._size, this._ratio);\r\n                }\r\n            }\r\n        },\r\n        methods: {\r\n            start (e, target) {                \r\n                e.stopPropagation();\r\n                this._moving = true;                \r\n                const {low, high, hasTooltip} = this.get();\r\n                this._startX = e.x;                \r\n                this._target = target;\r\n                switch (target) {\r\n                    case 'left':\r\n                        this._start = parseFloat (low);\r\n                        if (hasTooltip) {\r\n                            this.refs.leftTick.style.display = 'block';\r\n                        }                        \r\n                        break;\r\n                    case 'right':\r\n                        this._start = parseFloat (high);\r\n                        if (hasTooltip) {\r\n                            this.refs.rightTick.style.display = 'block';\r\n                        }                        \r\n                        break;\r\n                    default:\r\n                        break;\r\n                }                \r\n            },\r\n            move(e) {                \r\n                if (this._moving) {\r\n                    setTimeout(() => {\r\n                        e.stopPropagation();                                                            \r\n                        const {min, max, low, high, step, orientation} = this.get();\r\n                        const a = parseFloat(min);\r\n                        const z = parseFloat(max);\r\n                        const s = parseFloat (step);                                        \r\n                        let d = (e.x - this._startX) * this._ratio;                    \r\n                        if (s > 0) {\r\n                            d = Math.floor (d / s) * s;\r\n                        }\r\n                        const x = this._start + d;\r\n                        switch (this._target) {\r\n                            case 'left':\r\n                                const hi = parseFloat(high);\r\n                                if (!isNaN(a) && !isNaN(hi) && a <= x && x <= hi) {\r\n                                    this.set({low: x});\r\n                                }\r\n                                break;\r\n                            case 'right':\r\n                                const lo = parseFloat(low);                            \r\n                                if (!isNaN(z) && (!isNaN(lo) && lo <= x && x <= z || isNaN(lo) && !isNaN(a) && a <= x && x <= z)) {\r\n                                    this.set({high: x});\r\n                                }                            \r\n                                break;\r\n                            default:\r\n                                break;\r\n                        }\r\n                    }, TIMEOUT);\r\n                }\r\n            },\r\n            stop (e) {\r\n                this._moving = false;\r\n                const {isRange, hasTooltip} = this.get();\r\n                if (hasTooltip) {\r\n                    if (isRange) {\r\n                        this.refs.leftTick.style.display = 'none';\r\n                    }\r\n                    this.refs.rightTick.style.display = 'none';              \r\n                }                \r\n                this._target = null;\r\n            },\r\n            _getRatio (min, max, size) {\r\n                const a = parseFloat(min);\r\n                const z = parseFloat(max);        \r\n                if (!isNaN(a) && !isNaN(z)) {                            \r\n                    const {width, height} = this.refs.bar.getBoundingClientRect();\r\n                    return (z - a) / (width - size);\r\n                }\r\n                else {\r\n                    return NaN;\r\n                }\r\n            },\r\n            _updateDom (min, max, low, high, size, ratio) {\r\n                const a = parseFloat(min);\r\n                const z = parseFloat(max);\r\n                const lo = parseFloat(low);\r\n                const hi = parseFloat(high);\r\n                if (!isNaN(a) && !isNaN(z) && !isNaN(hi) && a <= hi && hi <= z) {                    \r\n                    this.refs.range.style.width = `${Math.round((!isNaN(lo) && a <= lo && lo <= hi ? (hi - lo) : hi) / ratio + size)}px`;\r\n                    if (!isNaN(lo) && a <= lo && lo <= hi) {\r\n                        this.refs.range.style.left = `${Math.round(lo / ratio)}px`;\r\n                    }\r\n                }\r\n            }            \r\n        },        \r\n    };\r\n</script>",
    "<svelte:window on:mouseup=\"stop(event)\" on:mousemove=\"move(event)\"/>\r\n<div class:vslider=\"true\">\r\n    <div class=\"bar\" ref:bar>\r\n        <div class=\"range\" ref:range>\r\n            {#if isRange}\r\n            <div class=\"left\" ref:left on:mousedown=\"start(event, 'left')\">\r\n                {#if hasTooltip}\r\n                    <div class=\"left-tick\" ref:leftTick>{parseFloat(low).toFixed()}</div>\r\n                {/if}\r\n            </div>\r\n            {/if}\r\n            <div class=\"right\" ref:right on:mousedown=\"start(event, 'right')\">\r\n                {#if hasTooltip}\r\n                    <div class=\"right-tick\" ref:rightTick>{parseFloat(high).toFixed()}</div>\r\n                {/if}\r\n            </div>\r\n        </div>\r\n    </div>\r\n    <slot></slot>\r\n</div>\r\n\r\n<style>\r\n    .vslider {  \r\n        -webkit-touch-callout: none;\r\n        -webkit-user-select: none;\r\n        -khtml-user-select: none;\r\n        -moz-user-select: none;\r\n        -ms-user-select: none;\r\n        user-select: none;\r\n    }    \r\n    .vslider .bar,\r\n    .vslider .bar .range,\r\n    .vslider .bar .range .left,\r\n    .vslider .bar .range .right {\r\n        position: relative;\r\n    }\r\n    .vslider .bar .range .left,\r\n    .vslider .bar .range .right {\r\n        width: 12px;\r\n        height: 12px;\r\n        cursor: pointer;\r\n        display: block;        \r\n    }    \r\n    .vslider .bar .range .left .left-tick,\r\n    .vslider .bar .range .right .right-tick {\r\n        position: relative;\r\n        left: 17px;\r\n        top: -3px;\r\n        display: none;\r\n    }    \r\n</style>\r\n\r\n<script>\r\n    const TIMEOUT = 70;\r\n    export default {\r\n        data () {\r\n            return {\r\n                min: 0,\r\n                max: 0,\r\n                low: NaN,\r\n                high: 0,\r\n                step: 0,\r\n                tooltip: false, \r\n            };\r\n        },\r\n        computed: {\r\n            isRange: ({low}) => !isNaN(parseFloat(low)),\r\n            hasTooltip: ({tooltip}) => {\r\n                switch (typeof tooltip) {\r\n                    case 'boolean':\r\n                        return tooltip;\r\n                    case 'string':\r\n                        return tooltip.toLowerCase() === 'true';\r\n                    default:\r\n                        return false;\r\n                }\r\n            }\r\n        },         \r\n        oncreate() {            \r\n            const {min, max, low, high, orientation, isRange} = this.get();\r\n            const height = this.refs.right.getBoundingClientRect().height;\r\n            this._size = isRange ? 2 * height : height;\r\n            this._ratio = this._getRatio(min, max, this._size);\r\n            this._updateDom(min, max, low, high, this._size, this._ratio);\r\n        },\r\n        onupdate({changed, current, previous}) {            \r\n            if (changed.low) {\r\n                const lo = parseFloat(current.low);\r\n                if (!isNaN(lo)) {\r\n                    const {min, max, high} = this.get();                    \r\n                    this._updateDom (min, max, lo, high, this._size, this._ratio);\r\n                }\r\n            }\r\n            if (changed.high) {\r\n                const hi = parseFloat(current.high);\r\n                if (!isNaN(hi)) {\r\n                    const {min, max, low} = this.get();\r\n                    this._updateDom (min, max, low, hi, this._size, this._ratio);\r\n                }\r\n            }\r\n        },\r\n        methods: {\r\n            start (e, target) {                \r\n                e.stopPropagation();\r\n                this._moving = true;                \r\n                const {low, high, hasTooltip} = this.get();\r\n                this._startX = e.y;\r\n                this._target = target;\r\n                switch (target) {\r\n                    case 'left':\r\n                        this._start = parseFloat (low);\r\n                        if (hasTooltip) {\r\n                            this.refs.leftTick.style.display = 'block';\r\n                        }                        \r\n                        break;\r\n                    case 'right':\r\n                        this._start = parseFloat (high);\r\n                        if (hasTooltip) {\r\n                            this.refs.rightTick.style.display = 'block';\r\n                        }\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }                \r\n            },\r\n            move(e) {                \r\n                if (this._moving) {\r\n                    setTimeout(() => {\r\n                        e.stopPropagation();                                                            \r\n                        const {min, max, low, high, step} = this.get();\r\n                        const a = parseFloat(min);\r\n                        const z = parseFloat(max);\r\n                        const s = parseFloat (step);                                        \r\n                        let d = (e.y - this._startX) * this._ratio;\r\n                        if (s > 0) {\r\n                            d = Math.floor (d / s) * s;\r\n                        }\r\n                        const x = this._start + d;\r\n                        switch (this._target) {\r\n                            case 'left':\r\n                                const hi = parseFloat(high);\r\n                                if (!isNaN(a) && !isNaN(hi) && a <= x && x <= hi) {\r\n                                    this.set({low: x});\r\n                                }\r\n                                break;\r\n                            case 'right':\r\n                                const lo = parseFloat(low);                            \r\n                                if (!isNaN(z) && (!isNaN(lo) && lo <= x && x <= z || isNaN(lo) && !isNaN(a) && a <= x && x <= z)) {\r\n                                    this.set({high: x});\r\n                                }                            \r\n                                break;\r\n                            default:\r\n                                break;\r\n                        }\r\n                    }, TIMEOUT);\r\n                }\r\n            },\r\n            stop (e) {\r\n                this._moving = false;\r\n                const {isRange, hasTooltip} = this.get();\r\n                if (hasTooltip) {\r\n                    if (isRange) {\r\n                        this.refs.leftTick.style.display = 'none';\r\n                    }                \r\n                    this.refs.rightTick.style.display = 'none';\r\n                }\r\n                this._target = null;                \r\n            },\r\n            _getRatio (min, max, size) {\r\n                const a = parseFloat(min);\r\n                const z = parseFloat(max);        \r\n                if (!isNaN(a) && !isNaN(z)) {                            \r\n                    const {width, height} = this.refs.bar.getBoundingClientRect();\r\n                    return (z - a) / (height - size);\r\n                }\r\n                else {\r\n                    return NaN;\r\n                }\r\n            },\r\n            _updateDom (min, max, low, high, size, ratio) {\r\n                const a = parseFloat(min);\r\n                const z = parseFloat(max);\r\n                const lo = parseFloat(low);\r\n                const hi = parseFloat(high);\r\n                if (!isNaN(a) && !isNaN(z) && !isNaN(hi) && a <= hi && hi <= z) {                    \r\n                    const h = (!isNaN(lo) && a <= lo && lo <= hi ? (hi - lo) : hi) / ratio + size;\r\n                    this.refs.range.style.height = `${Math.round(h)}px`;\r\n                    this.refs.right.style.top = `${h - size}px`;\r\n                    if (!isNaN(lo) && a <= lo && lo <= hi) {\r\n                        this.refs.range.style.top = `${Math.round(lo / ratio)}px`;                        \r\n                    }\r\n                }\r\n            }           \r\n        },        \r\n    };\r\n</script>"
  ],
  "names": [],
  "mappings": "AAsBI,QAAQ,cAAC,CAAC,AACN,qBAAqB,CAAE,IAAI,CAC3B,mBAAmB,CAAE,IAAI,CACzB,kBAAkB,CAAE,IAAI,CACxB,gBAAgB,CAAE,IAAI,CACtB,eAAe,CAAE,IAAI,CACrB,WAAW,CAAE,IAAI,AACrB,CAAC,AACD,sBAAQ,CAAC,kBAAI,CACb,sBAAQ,CAAC,IAAI,CAAC,oBAAM,CACpB,sBAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,mBAAK,CAC1B,sBAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,cAAC,CAAC,AACzB,QAAQ,CAAE,QAAQ,AACtB,CAAC,AACD,sBAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,mBAAK,CAC1B,sBAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,cAAC,CAAC,AACzB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,MAAM,CAAE,OAAO,AACnB,CAAC,AACD,sBAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,cAAC,CAAC,AACxB,KAAK,CAAE,IAAI,AACf,CAAC,AACD,sBAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,cAAC,CAAC,AACzB,KAAK,CAAE,KAAK,AAChB,CAAC,AACD,sBAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,wBAAU,CACrC,sBAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,WAAW,cAAC,CAAC,AACrC,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,IAAI,CACV,GAAG,CAAE,KAAK,CACV,OAAO,CAAE,IAAI,AACjB,CAAC;AChCD,QAAQ,cAAC,CAAC,AACN,qBAAqB,CAAE,IAAI,CAC3B,mBAAmB,CAAE,IAAI,CACzB,kBAAkB,CAAE,IAAI,CACxB,gBAAgB,CAAE,IAAI,CACtB,eAAe,CAAE,IAAI,CACrB,WAAW,CAAE,IAAI,AACrB,CAAC,AACD,sBAAQ,CAAC,kBAAI,CACb,sBAAQ,CAAC,IAAI,CAAC,oBAAM,CACpB,sBAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,mBAAK,CAC1B,sBAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,cAAC,CAAC,AACzB,QAAQ,CAAE,QAAQ,AACtB,CAAC,AACD,sBAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,mBAAK,CAC1B,sBAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,cAAC,CAAC,AACzB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,MAAM,CAAE,OAAO,CACf,OAAO,CAAE,KAAK,AAClB,CAAC,AACD,sBAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,wBAAU,CACrC,sBAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,WAAW,cAAC,CAAC,AACrC,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,IAAI,CACV,GAAG,CAAE,IAAI,CACT,OAAO,CAAE,IAAI,AACjB,CAAC"
}